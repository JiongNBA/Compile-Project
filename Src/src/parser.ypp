%{
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <string>
#include <vector>
#include <utility>
#include <FlexLexer.h>
#include "../include/AST.h"
#include "../include/SymTable.h"
#include "../include/semantic.h"
extern FlexLexer *lexer;
extern BaseAST *root;
extern BaseAST *lastId;
extern int yylex(void);
extern SymTable symTable;
int yyerror(std::string str);
using namespace std;

#define YYSTYPE BaseAST*

SymTable symTable;

vector<BaseAST *> parent;
int level = 0;
vector<int> addrs;
std::string curType;
std::stack<BaseAST *> ids;

%}

%token LEFT_PAR
%token RIGHT_PAR
%token LEFT_CURLY
%token RIGHT_CURLY
%token LEFT_SQUARE
%token RIGHT_SQUARE
%token COMMA
%token SEMICOLON

%token IF
%token ELSE
%token FOR
%token WHILE
%token RETURN
%token BREAK
%token CONTINUE

%token ID
%token NUM
%token LITERAL
%token CH

%token INT
%token FLOAT
%token CHAR
%token VOID

%token ADD
%token SUB
%token MUL
%token DIV
%token ASSIGN
%token NOT
%token OR
%token AND
%token EQUAL
%token UEQUAL
%token GR
%token GE
%token LS
%token LE
%token ADDR

%%
doc: stmt { }
   ;
stmt: stmt unit { }
    | unit { }
    ;
unit: def-stmt SEMICOLON { }
    | func { root->addChild($1); }
    ;
func: type ID LEFT_PAR {$$ = Func::func(curType, yylval->val); level++; delete yylval;} parlist RIGHT_PAR block RIGHT_CURLY {symTable.delTable(level); level--; $$=parent[0]; parent.pop_back(); } 
    | type ID LEFT_PAR {$$ = Func::func(curType, yylval->val); level++; delete yylval;} RIGHT_PAR block RIGHT_CURLY {symTable.delTable(level); level--; $$=parent[0]; parent.pop_back();}
    ;
block: block stmt2 { $$ = $2; }
     | LEFT_CURLY { $$ = NULL; }
     ;
stmt2: ctrl-stmt {}
     | op-stmt SEMICOLON {}
     | ret-stmt SEMICOLON { $$ = $1; }
     | BREAK SEMICOLON {}
     | CONTINUE SEMICOLON {}
     | SEMICOLON {}
     ;
ctrl-stmt: cond-stmt {}
         | for-stmt {}
         | while-stmt {}
         ;
op-stmt: exp-list {}
       | def-stmt { $$ = $1;}
       ;
cond-stmt: if-stmt elif-list else-stmt {}
         ;
if-stmt: IF LEFT_PAR exp RIGHT_PAR block RIGHT_CURLY {}
       ;                          
else-stmt: ELSE block RIGHT_CURLY {}
         | {}
         ;
elif-list: elif-list ELSE IF LEFT_PAR exp RIGHT_PAR block RIGHT_CURLY {}
         | {}
         ;
for-stmt: FOR LEFT_PAR op-stmt SEMICOLON exp SEMICOLON op-stmt RIGHT_PAR block RIGHT_CURLY {}
        ;
while-stmt: WHILE LEFT_PAR exp RIGHT_PAR block RIGHT_CURLY {}
          ;
exp-list: exp-list COMMA exp { parent[level-1]->child.push_back($3); }
        | exp { parent[level-1]->child.push_back($1); }
        ;
def-stmt: type def-stmt2 {$$ = $2;}
        ;
def-stmt2: def-stmt2 COMMA def-stmt3 {$$ = $3;}
         | def-stmt3 { $$ = $1; }
         ;
def-stmt3: ID {ids.push(yylval);} ASSIGN exp { BaseAST *id = ids.top(); $$ = DefStmt::def(curType, id->val, false, $4, level); ids.pop(); delete id; }
         | ID subsript-list {}
         | ID { $$ = DefStmt::def(curType, yylval->val, false, level); delete yylval;}
         | ID subsript-list ASSIGN LEFT_CURLY varlist RIGHT_CURLY {}
         ;
subsript-list: subsript-list subsript {}
             | subsript {}
             ;
subsript: LEFT_SQUARE exp RIGHT_SQUARE {}
        ;
ret-stmt: RETURN exp { $$ = RetStmt::ret($2);}
        ;
parlist: VOID {}
       | NEparlist {}
       ;
NEparlist: NEparlist COMMA dec-stmt {}
       | dec-stmt {}
       ;
dec-stmt: type ID {DecStmt::dec(curType, yylval->val, false);}                
        | type ID LEFT_SQUARE RIGHT_SQUARE {DecStmt::dec(curType, yylval->val, true);}
        ;
type: INT { curType = "INT";}
    | FLOAT { curType = "FLOAT";}
    | CHAR  { curType = "CHAR";}
    | VOID  { curType = "VOID";}
    ;
varlist: varlist COMMA exp { ids.top()->child.push_back($3); }
       | exp               { ids.top()->child.push_back($1); }
       ;
// ()
// func id
// &
// ! -(uni)
// * /
// + -
// > < >= <= 
// == !=
// &&
// || 

exp: ID ASSIGN {BaseAST *assign = Exp::assign_exp(yylval); ids.push(assign); } exp {BaseAST *assign = ids.top(); assign->child.push_back($4); $$ = assign; ids.pop(); }
   | ID subsript-list ASSIGN {} exp {}
   | exp0 { $$ = $1; }
   ;
exp0: exp0 OR exp1 {$$ = Exp::binary_exp($1,$3,B_OR);}
   | exp1 { $$ = $1; }
   ;
   
exp1: exp1 AND exp2 {$$ = Exp::binary_exp($1,$3,B_AND);}
    | exp2 { $$ = $1; }
    ;
    
exp2: exp2 EQUAL  exp3 {$$ = Exp::binary_exp($1,$3,B_EQ);}
    | exp2 UEQUAL exp3 {$$ = Exp::binary_exp($1,$3,B_UEQ);}
    | exp3 { $$ = $1; }
    ;
    
exp3: exp3 GR exp4 {$$ = Exp::binary_exp($1,$3,B_GR);}
    | exp3 GE exp4 {$$ = Exp::binary_exp($1,$3,B_GE);}
    | exp3 LS exp4 {$$ = Exp::binary_exp($1,$3,B_LS);}
    | exp3 LE exp4 {$$ = Exp::binary_exp($1,$3,B_LE);}
    | exp4 { $$ = $1; }
    ;

exp4: exp4 ADD exp5 {$$ = Exp::binary_exp($1,$3,B_ADD);}
    | exp4 SUB exp5 {$$ = Exp::binary_exp($1,$3,B_SUB);}
    | exp5 { $$ = $1; }
    ;
    
exp5: exp5 MUL exp6 {$$ = Exp::binary_exp($1,$3,B_MUL); }
    | exp5 DIV exp6 {$$ = Exp::binary_exp($1,$3,B_DIV); }
    | exp6 { $$ = $1; }
    ;
    
exp6: SUB exp6 { $$ = Exp::sub_exp($2); }
    | NOT exp6 { $$ = Exp::not_exp($2); }
    | exp7 { $$ = $1; }
    ;

exp7: LEFT_PAR exp RIGHT_PAR { $$ = $2; }
    | NUM { $$ = Exp::exp(yylval->val, yylval->dtype); delete yylval; }
    | ID LEFT_PAR { BaseAST *fa = FuncCall::funcCall(lastId->val); ids.push(fa);} varlist RIGHT_PAR {$$ = ids.top(); ids.pop();}
    | ID LEFT_PAR { BaseAST *fa = FuncCall::funcCall(lastId->val); ids.push(fa);} RIGHT_PAR {$$ = ids.top(); ids.pop();}
    | ID subsript-list {}
    | ID { $$ = Exp::exp(yylval->val); delete yylval;}
    | LITERAL { $$ = Exp::exp(yylval->val, yylval->dtype); delete yylval; }
    | CH { $$ = Exp::exp(yylval->val, yylval->dtype); delete yylval; }
    | ADDR ID { $$ = Exp::addr_exp(yylval->val); delete yylval; }
    | ADDR ID subsript-list {}
    ;


%%

int yyerror(string str)
{ 
    fprintf(stderr, "[ERROR] %s\n", lexer->YYText());
    return 0;
}